{"version":3,"sources":["fuse.min.js"],"names":["global","log","console","apply","arguments","Fuse","list","options","key","this","defaultOptions","hasOwnProperty","deepValue","obj","path","firstSegment","remaining","dotIndex","value","i","len","indexOf","slice","undefined","isArray","length","push","Object","prototype","toString","call","BitapSearcher","pattern","location","distance","threshold","maxPatternLength","caseSensitive","toLowerCase","patternLen","matchmask","patternAlphabet","_calculatePatternAlphabet","id","include","shouldSort","searchFn","sortFn","a","b","score","getFn","keys","verbose","tokenize","matchAllTokens","tokenSeparator","minMatchCharLen","findAllMatches","VERSION","set","search","results","resultMap","_keyMap","_prepareSearchers","_startSearch","_computeScore","_sort","output","_format","tokens","split","tokenSearchers","fullSeacher","weight","j","listLen","keysLen","item","_analyze","name","Error","text","entity","index","words","scores","existingResult","averageScore","finalScore","scoresLen","mainSearchResult","tokenSearcher","termScores","word","tokenSearchResult","hasMatchInText","checkTextMatches","exists","numTextMatches","isMatch","matchedIndices","totalScore","scoreLen","bestScore","nScore","keyMap","Math","min","sort","replaceValue","getItemAtIndex","finalOutput","data","_item","_result","record","matches","indices","mask","charAt","_bitapScore","errors","accuracy","proximity","abs","textLen","bestLoc","binMin","binMid","binMax","start","finish","bitArr","lastBitArr","charMatch","locations","isMatched","matchMask","matchesLen","match","RegExp","replace","lastIndexOf","floor","max","Array","_getMatchedIndices","end","exports","module","define","amd"],"mappings":"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","file":"fuse.min.js","sourcesContent":["/**\n * @license\n * Fuse - Lightweight fuzzy-search\n *\n * Copyright (c) 2012-2016 Kirollos Risk <kirollos@gmail.com>.\n * All Rights Reserved. Apache Software License 2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n;(function (global) {\n  'use strict'\n\n  /** @type {function(...*)} */\n  function log () {\n    console.log.apply(console, arguments)\n  }\n\n  var defaultOptions = {\n    // The name of the identifier property. If specified, the returned result will be a list\n    // of the items' dentifiers, otherwise it will be a list of the items.\n    id: null,\n\n    // Indicates whether comparisons should be case sensitive.\n\n    caseSensitive: false,\n\n    // An array of values that should be included from the searcher's output. When this array\n    // contains elements, each result in the list will be of the form `{ item: ..., include1: ..., include2: ... }`.\n    // Values you can include are `score`, `matchedLocations`\n    include: [],\n\n    // Whether to sort the result list, by score\n    shouldSort: true,\n\n    // The search function to use\n    // Note that the default search function ([[Function]]) must conform to the following API:\n    //\n    //  @param pattern The pattern string to search\n    //  @param options The search option\n    //  [[Function]].constructor = function(pattern, options)\n    //\n    //  @param text: the string to search in for the pattern\n    //  @return Object in the form of:\n    //    - isMatch: boolean\n    //    - score: Int\n    //  [[Function]].prototype.search = function(text)\n    searchFn: BitapSearcher,\n\n    // Default sort function\n    sortFn: function (a, b) {\n      return a.score - b.score\n    },\n\n    // The get function to use when fetching an object's properties.\n    // The default will search nested paths *ie foo.bar.baz*\n    getFn: deepValue,\n\n    // List of properties that will be searched. This also supports nested properties.\n    keys: [],\n\n    // Will print to the console. Useful for debugging.\n    verbose: false,\n\n    // When true, the search algorithm will search individual words **and** the full string,\n    // computing the final score as a function of both. Note that when `tokenize` is `true`,\n    // the `threshold`, `distance`, and `location` are inconsequential for individual tokens.\n    tokenize: false,\n\n    // When true, the result set will only include records that match all tokens. Will only work\n    // if `tokenize` is also true.\n    matchAllTokens: false,\n\n    // Regex used to separate words when searching. Only applicable when `tokenize` is `true`.\n    tokenSeparator: / +/g,\n\n    // Minimum number of characters that must be matched before indices are returned\n    minMatchCharLen: 1,\n\n    // Continue to end of text even if perfect match is found before hand\n    findAllMatches: false\n  }\n\n  /**\n   * @constructor\n   * @param {!Array} list\n   * @param {!Object<string, *>} options\n   */\n  function Fuse (list, options) {\n    var i\n    var len\n    var key\n    var keys\n\n    this.list = list\n    this.options = options = options || {}\n\n    for (key in defaultOptions) {\n      if (!defaultOptions.hasOwnProperty(key)) {\n        continue;\n      }\n      // Add boolean type options\n      if (typeof defaultOptions[key] === 'boolean') {\n        this.options[key] = key in options ? options[key] : defaultOptions[key];\n      // Add all other options\n      } else {\n        this.options[key] = options[key] || defaultOptions[key]\n      }\n    }\n  }\n\n  Fuse.VERSION = '2.5.0'\n\n  /**\n   * Sets a new list for Fuse to match against.\n   * @param {!Array} list\n   * @return {!Array} The newly set list\n   * @public\n   */\n  Fuse.prototype.set = function (list) {\n    this.list = list\n    return list\n  }\n\n  Fuse.prototype.search = function (pattern) {\n    if (this.options.verbose) log('\\nSearch term:', pattern, '\\n')\n\n    this.pattern = pattern\n    this.results = []\n    this.resultMap = {}\n    this._keyMap = null\n\n    this._prepareSearchers()\n    this._startSearch()\n    this._computeScore()\n    this._sort()\n\n    var output = this._format()\n    return output\n  }\n\n  Fuse.prototype._prepareSearchers = function () {\n    var options = this.options\n    var pattern = this.pattern\n    var searchFn = options.searchFn\n    var tokens = pattern.split(options.tokenSeparator)\n    var i = 0\n    var len = tokens.length\n\n    if (this.options.tokenize) {\n      this.tokenSearchers = []\n      for (; i < len; i++) {\n        this.tokenSearchers.push(new searchFn(tokens[i], options))\n      }\n    }\n    this.fullSeacher = new searchFn(pattern, options)\n  }\n\n  Fuse.prototype._startSearch = function () {\n    var options = this.options\n    var getFn = options.getFn\n    var list = this.list\n    var listLen = list.length\n    var keys = this.options.keys\n    var keysLen = keys.length\n    var key\n    var weight\n    var item = null\n    var i\n    var j\n\n    // Check the first item in the list, if it's a string, then we assume\n    // that every item in the list is also a string, and thus it's a flattened array.\n    if (typeof list[0] === 'string') {\n      // Iterate over every item\n      for (i = 0; i < listLen; i++) {\n        this._analyze('', list[i], i, i)\n      }\n    } else {\n      this._keyMap = {}\n      // Otherwise, the first item is an Object (hopefully), and thus the searching\n      // is done on the values of the keys of each item.\n      // Iterate over every item\n      for (i = 0; i < listLen; i++) {\n        item = list[i]\n        // Iterate over every key\n        for (j = 0; j < keysLen; j++) {\n          key = keys[j]\n          if (typeof key !== 'string') {\n            weight = (1 - key.weight) || 1\n            this._keyMap[key.name] = {\n              weight: weight\n            }\n            if (key.weight <= 0 || key.weight > 1) {\n              throw new Error('Key weight has to be > 0 and <= 1')\n            }\n            key = key.name\n          } else {\n            this._keyMap[key] = {\n              weight: 1\n            }\n          }\n          this._analyze(key, getFn(item, key, []), item, i)\n        }\n      }\n    }\n  }\n\n  Fuse.prototype._analyze = function (key, text, entity, index) {\n    var options = this.options\n    var words\n    var scores\n    var exists = false\n    var existingResult\n    var averageScore\n    var finalScore\n    var scoresLen\n    var mainSearchResult\n    var tokenSearcher\n    var termScores\n    var word\n    var tokenSearchResult\n    var hasMatchInText\n    var checkTextMatches\n    var i\n    var j\n\n    // Check if the text can be searched\n    if (text === undefined || text === null) {\n      return\n    }\n\n    scores = []\n\n    var numTextMatches = 0\n\n    if (typeof text === 'string') {\n      words = text.split(options.tokenSeparator)\n\n      if (options.verbose) log('---------\\nKey:', key)\n\n      if (this.options.tokenize) {\n        for (i = 0; i < this.tokenSearchers.length; i++) {\n          tokenSearcher = this.tokenSearchers[i]\n\n          if (options.verbose) log('Pattern:', tokenSearcher.pattern)\n\n          termScores = []\n          hasMatchInText = false\n\n          for (j = 0; j < words.length; j++) {\n            word = words[j]\n            tokenSearchResult = tokenSearcher.search(word)\n            var obj = {}\n            if (tokenSearchResult.isMatch) {\n              obj[word] = tokenSearchResult.score\n              exists = true\n              hasMatchInText = true\n              scores.push(tokenSearchResult.score)\n            } else {\n              obj[word] = 1\n              if (!this.options.matchAllTokens) {\n                scores.push(1)\n              }\n            }\n            termScores.push(obj)\n          }\n\n          if (hasMatchInText) {\n            numTextMatches++\n          }\n\n          if (options.verbose) log('Token scores:', termScores)\n        }\n\n        averageScore = scores[0]\n        scoresLen = scores.length\n        for (i = 1; i < scoresLen; i++) {\n          averageScore += scores[i]\n        }\n        averageScore = averageScore / scoresLen\n\n        if (options.verbose) log('Token score average:', averageScore)\n      }\n\n      mainSearchResult = this.fullSeacher.search(text)\n      if (options.verbose) log('Full text score:', mainSearchResult.score)\n\n      finalScore = mainSearchResult.score\n      if (averageScore !== undefined) {\n        finalScore = (finalScore + averageScore) / 2\n      }\n\n      if (options.verbose) log('Score average:', finalScore)\n\n      checkTextMatches = (this.options.tokenize && this.options.matchAllTokens) ? numTextMatches >= this.tokenSearchers.length : true\n\n      if (options.verbose) log('Check Matches', checkTextMatches)\n\n      // If a match is found, add the item to <rawResults>, including its score\n      if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n        // Check if the item already exists in our results\n        existingResult = this.resultMap[index]\n\n        if (existingResult) {\n          // Use the lowest score\n          // existingResult.score, bitapResult.score\n          existingResult.output.push({\n            key: key,\n            score: finalScore,\n            matchedIndices: mainSearchResult.matchedIndices\n          })\n        } else {\n          // Add it to the raw result list\n          this.resultMap[index] = {\n            item: entity,\n            output: [{\n              key: key,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            }]\n          }\n\n          this.results.push(this.resultMap[index])\n        }\n      }\n    } else if (isArray(text)) {\n      for (i = 0; i < text.length; i++) {\n        this._analyze(key, text[i], entity, index)\n      }\n    }\n  }\n\n  Fuse.prototype._computeScore = function () {\n    var i\n    var j\n    var keyMap = this._keyMap\n    var totalScore\n    var output\n    var scoreLen\n    var score\n    var weight\n    var results = this.results\n    var bestScore\n    var nScore\n\n    if (this.options.verbose) log('\\n\\nComputing score:\\n')\n\n    for (i = 0; i < results.length; i++) {\n      totalScore = 0\n      output = results[i].output\n      scoreLen = output.length\n\n      bestScore = 1\n\n      for (j = 0; j < scoreLen; j++) {\n        score = output[j].score\n        weight = keyMap ? keyMap[output[j].key].weight : 1\n\n        nScore = score * weight\n\n        if (weight !== 1) {\n          bestScore = Math.min(bestScore, nScore)\n        } else {\n          totalScore += nScore\n          output[j].nScore = nScore\n        }\n      }\n\n      if (bestScore === 1) {\n        results[i].score = totalScore / scoreLen\n      } else {\n        results[i].score = bestScore\n      }\n\n      if (this.options.verbose) log(results[i])\n    }\n  }\n\n  Fuse.prototype._sort = function () {\n    var options = this.options\n    if (options.shouldSort) {\n      if (options.verbose) log('\\n\\nSorting....')\n      this.results.sort(options.sortFn)\n    }\n  }\n\n  Fuse.prototype._format = function () {\n    var options = this.options\n    var getFn = options.getFn\n    var finalOutput = []\n    var item\n    var i\n    var len\n    var results = this.results\n    var replaceValue\n    var getItemAtIndex\n    var include = options.include\n\n    if (options.verbose) log('\\n\\nOutput:\\n\\n', results)\n\n    // Helper function, here for speed-up, which replaces the item with its value,\n    // if the options specifies it,\n    replaceValue = options.id ? function (index) {\n      results[index].item = getFn(results[index].item, options.id, [])[0]\n    } : function () {}\n\n    getItemAtIndex = function (index) {\n      var record = results[index]\n      var data\n      var j\n      var output\n      var _item\n      var _result\n\n      // If `include` has values, put the item in the result\n      if (include.length > 0) {\n        data = {\n          item: record.item\n        }\n        if (include.indexOf('matches') !== -1) {\n          output = record.output\n          data.matches = []\n          for (j = 0; j < output.length; j++) {\n            _item = output[j]\n            _result = {\n              indices: _item.matchedIndices\n            }\n            if (_item.key) {\n              _result.key = _item.key\n            }\n            data.matches.push(_result)\n          }\n        }\n\n        if (include.indexOf('score') !== -1) {\n          data.score = results[index].score\n        }\n\n      } else {\n        data = record.item\n      }\n\n      return data\n    }\n\n    // From the results, push into a new array only the item identifier (if specified)\n    // of the entire item.  This is because we don't want to return the <results>,\n    // since it contains other metadata\n    for (i = 0, len = results.length; i < len; i++) {\n      replaceValue(i)\n      item = getItemAtIndex(i)\n      finalOutput.push(item)\n    }\n\n    return finalOutput\n  }\n\n  // Helpers\n\n  function deepValue (obj, path, list) {\n    var firstSegment\n    var remaining\n    var dotIndex\n    var value\n    var i\n    var len\n\n    if (!path) {\n      // If there's no path left, we've gotten to the object we care about.\n      list.push(obj)\n    } else {\n      dotIndex = path.indexOf('.')\n\n      if (dotIndex !== -1) {\n        firstSegment = path.slice(0, dotIndex)\n        remaining = path.slice(dotIndex + 1)\n      } else {\n        firstSegment = path\n      }\n\n      value = obj[firstSegment]\n      if (value !== null && value !== undefined) {\n        if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n          list.push(value)\n        } else if (isArray(value)) {\n          // Search each item in the array.\n          for (i = 0, len = value.length; i < len; i++) {\n            deepValue(value[i], remaining, list)\n          }\n        } else if (remaining) {\n          // An object. Recurse further.\n          deepValue(value, remaining, list)\n        }\n      }\n    }\n\n    return list\n  }\n\n  function isArray (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]'\n  }\n\n  /**\n   * Adapted from \"Diff, Match and Patch\", by Google\n   *\n   *   http://code.google.com/p/google-diff-match-patch/\n   *\n   * Modified by: Kirollos Risk <kirollos@gmail.com>\n   * -----------------------------------------------\n   * Details: the algorithm and structure was modified to allow the creation of\n   * <Searcher> instances with a <search> method which does the actual\n   * bitap search. The <pattern> (the string that is searched for) is only defined\n   * once per instance and thus it eliminates redundant re-creation when searching\n   * over a list of strings.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\")\n   * you may not use this file except in compliance with the License.\n   *\n   * @constructor\n   */\n  function BitapSearcher (pattern, options) {\n    options = options || {}\n    this.options = options\n    this.options.location = options.location || BitapSearcher.defaultOptions.location\n    this.options.distance = 'distance' in options ? options.distance : BitapSearcher.defaultOptions.distance\n    this.options.threshold = 'threshold' in options ? options.threshold : BitapSearcher.defaultOptions.threshold\n    this.options.maxPatternLength = options.maxPatternLength || BitapSearcher.defaultOptions.maxPatternLength\n\n    this.pattern = options.caseSensitive ? pattern : pattern.toLowerCase()\n    this.patternLen = pattern.length\n\n    if (this.patternLen <= this.options.maxPatternLength) {\n      this.matchmask = 1 << (this.patternLen - 1)\n      this.patternAlphabet = this._calculatePatternAlphabet()\n    }\n  }\n\n  BitapSearcher.defaultOptions = {\n    // Approximately where in the text is the pattern expected to be found?\n    location: 0,\n\n    // Determines how close the match must be to the fuzzy location (specified above).\n    // An exact letter match which is 'distance' characters away from the fuzzy location\n    // would score as a complete mismatch. A distance of '0' requires the match be at\n    // the exact location specified, a threshold of '1000' would require a perfect match\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n    distance: 100,\n\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n    // (of both letters and location), a threshold of '1.0' would match anything.\n    threshold: 0.6,\n\n    // Machine word size\n    maxPatternLength: 32\n  }\n\n  /**\n   * Initialize the alphabet for the Bitap algorithm.\n   * @return {Object} Hash of character locations.\n   * @private\n   */\n  BitapSearcher.prototype._calculatePatternAlphabet = function () {\n    var mask = {},\n      i = 0\n\n    for (i = 0; i < this.patternLen; i++) {\n      mask[this.pattern.charAt(i)] = 0\n    }\n\n    for (i = 0; i < this.patternLen; i++) {\n      mask[this.pattern.charAt(i)] |= 1 << (this.pattern.length - i - 1)\n    }\n\n    return mask\n  }\n\n  /**\n   * Compute and return the score for a match with `e` errors and `x` location.\n   * @param {number} errors Number of errors in match.\n   * @param {number} location Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  BitapSearcher.prototype._bitapScore = function (errors, location) {\n    var accuracy = errors / this.patternLen,\n      proximity = Math.abs(this.options.location - location)\n\n    if (!this.options.distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy\n    }\n    return accuracy + (proximity / this.options.distance)\n  }\n\n  /**\n   * Compute and return the result of the search\n   * @param {string} text The text to search in\n   * @return {{isMatch: boolean, score: number}} Literal containing:\n   *                          isMatch - Whether the text is a match or not\n   *                          score - Overall score for the match\n   * @public\n   */\n  BitapSearcher.prototype.search = function (text) {\n    var options = this.options\n    var i\n    var j\n    var textLen\n    var location\n    var threshold\n    var bestLoc\n    var binMin\n    var binMid\n    var binMax\n    var start, finish\n    var bitArr\n    var lastBitArr\n    var charMatch\n    var score\n    var locations\n    var matches\n    var isMatched\n    var matchMask\n    var matchedIndices\n    var matchesLen\n    var match\n\n    text = options.caseSensitive ? text : text.toLowerCase()\n\n    if (this.pattern === text) {\n      // Exact match\n      return {\n        isMatch: true,\n        score: 0,\n        matchedIndices: [[0, text.length - 1]]\n      }\n    }\n\n    // When pattern length is greater than the machine word length, just do a a regex comparison\n    if (this.patternLen > options.maxPatternLength) {\n      matches = text.match(new RegExp(this.pattern.replace(options.tokenSeparator, '|')))\n      isMatched = !!matches\n\n      if (isMatched) {\n        matchedIndices = []\n        for (i = 0, matchesLen = matches.length; i < matchesLen; i++) {\n          match = matches[i]\n          matchedIndices.push([text.indexOf(match), match.length - 1])\n        }\n      }\n\n      return {\n        isMatch: isMatched,\n        // TODO: revisit this score\n        score: isMatched ? 0.5 : 1,\n        matchedIndices: matchedIndices\n      }\n    }\n\n    location = options.location\n    // Set starting location at beginning text and initialize the alphabet.\n    textLen = text.length\n    // Highest score beyond which we give up.\n    threshold = options.threshold\n    // Is there a nearby exact match? (speedup)\n    bestLoc = text.indexOf(this.pattern, location)\n\n    // a mask of the matches\n    matchMask = []\n    for (i = 0; i < textLen; i++) {\n      matchMask[i] = 0\n    }\n\n    if (bestLoc != -1) {\n      threshold = Math.min(this._bitapScore(0, bestLoc), threshold)\n      // What about in the other direction? (speed up)\n      bestLoc = text.lastIndexOf(this.pattern, location + this.patternLen)\n\n      if (bestLoc != -1) {\n        threshold = Math.min(this._bitapScore(0, bestLoc), threshold)\n      }\n    }\n\n    bestLoc = -1\n    score = 1\n    locations = []\n    binMax = this.patternLen + textLen\n\n    for (i = 0; i < this.patternLen; i++) {\n      // Scan for the best match; each iteration allows for one more error.\n      // Run a binary search to determine how far from the match location we can stray\n      // at this error level.\n      binMin = 0\n      binMid = binMax\n      while (binMin < binMid) {\n        if (this._bitapScore(i, location + binMid) <= threshold) {\n          binMin = binMid\n        } else {\n          binMax = binMid\n        }\n        binMid = Math.floor((binMax - binMin) / 2 + binMin)\n      }\n\n      // Use the result from this iteration as the maximum for the next.\n      binMax = binMid\n      start = Math.max(1, location - binMid + 1)\n      if (this.options.findAllMatches) {\n        finish = textLen;\n      } else {\n        finish = Math.min(location + binMid, textLen) + this.patternLen\n      }\n\n      // Initialize the bit array\n      bitArr = Array(finish + 2)\n\n      bitArr[finish + 1] = (1 << i) - 1\n\n      for (j = finish; j >= start; j--) {\n        charMatch = this.patternAlphabet[text.charAt(j - 1)]\n\n        if (charMatch) {\n          matchMask[j - 1] = 1\n        }\n\n        if (i === 0) {\n          // First pass: exact match.\n          bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch\n        } else {\n          // Subsequent passes: fuzzy match.\n          bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch | (((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1) | lastBitArr[j + 1]\n        }\n        if (bitArr[j] & this.matchmask) {\n          score = this._bitapScore(i, j - 1)\n\n          // This match will almost certainly be better than any existing match.\n          // But check anyway.\n          if (score <= threshold) {\n            // Indeed it is\n            threshold = score\n            bestLoc = j - 1\n            locations.push(bestLoc)\n\n            if (bestLoc > location) {\n              // When passing loc, don't exceed our current distance from loc.\n              start = Math.max(1, 2 * location - bestLoc)\n            } else {\n              // Already passed loc, downhill from here on in.\n              break\n            }\n          }\n        }\n      }\n\n      // No hope for a (better) match at greater error levels.\n      if (this._bitapScore(i + 1, location) > threshold) {\n        break\n      }\n      lastBitArr = bitArr\n    }\n\n    matchedIndices = this._getMatchedIndices(matchMask)\n\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    return {\n      isMatch: bestLoc >= 0,\n      score: score === 0 ? 0.001 : score,\n      matchedIndices: matchedIndices\n    }\n  }\n\n  BitapSearcher.prototype._getMatchedIndices = function (matchMask) {\n    var matchedIndices = []\n    var start = -1\n    var end = -1\n    var i = 0\n    var match\n    var len = matchMask.length\n    for (; i < len; i++) {\n      match = matchMask[i]\n      if (match && start === -1) {\n        start = i\n      } else if (!match && start !== -1) {\n        end = i - 1\n        if ((end - start) + 1 >= this.options.minMatchCharLen) {\n            matchedIndices.push([start, end])\n        }\n        start = -1\n      }\n    }\n    if (matchMask[i - 1]) {\n      if ((i-1 - start) + 1 >= this.options.minMatchCharLen) {\n        matchedIndices.push([start, i - 1])\n      }\n    }\n    return matchedIndices\n  }\n\n  // Export to Common JS Loader\n  if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Fuse\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(function () {\n      return Fuse\n    })\n  } else {\n    // Browser globals (root is window)\n    global.Fuse = Fuse\n  }\n\n})(this);\n"]}